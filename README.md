# LightSpring
Как же решить все эти проблемы:
- Вынести всю информацию, которая может измениться во внешние файлы. Проперти или еще что-нибудь.
- Разъединение на интерфейсы. Это поможет избежать сильной связанности. То есть нужно создавать дополнительный интерфейс
на реализацию класса. Тем самым мы завяжемся только на интерфейсы.
Или же чтобы нам кто- нибудь подсунул эту реализацию. Для этого даже есть название Inject Dependency.
Тут самое главное, что мы не пишем модификатор new, а получаем экземпляр класса, написанный кем-то. В нашем случае - это Spring framework.

Теперь давайте подумаем, кто будет заниматься созданием наших объектов. Этим будет заниматься Spring Container. Он будет их создавать,
он будет их соединять, а далее мы будем к нему обращаться за необходимой информацией.
То есть он создаст объекты класса, которые мы опишем. Данные объекты spring называются beans.

Далее spring поймет, что Client и Logger нужно будет засунуть в App. Проверит, чтобы не было циклических зависимостей. И все объекты живут.
Осталось только к нему обратиться.

Как же спринг поймет, какие ,бины ему нужно создать. Для этого есть xml файл, где и прописываются эти бины.
Также можно использовать аннотации.

В xml. Самое главное мы определяем тег <beans>. В нем мы прописываем какие xml схемы мы будем использовать.
В бинах мы указываем им id и объект класса, которого мы хотим создать.

<bean id="client" class="Client"> </bean>
    
Если мы хотим передать информацию в конструтор, то пишем :
    <bean id="client" class="Client">
    <constructor-arg value = "1"/>
    <constructor-arg value = "John Smith"/>
    </bean>
    
Допустим, аргументы могут иметь одинаковые типы, например String. По умолчанию, Spring инжектит значения в том порядке, в котором мы пишем в xml. Если мы хотим изменить порядок, то можно написать index.
    <bean id="client" class="Client">
    <constructor-arg index="0"  value = "1"/>
    <constructor-arg index="1"  value = "John Smith"/>
    </bean>
    
    Индексы, это хорошо, пока в них несколько аргументов. А бывает так, что их к примеру штук 20 и мы укажем всем им String. И мы захотим впихнуть всередине еще один индекс. Придется менять все индексы идущие за ним. Или просто не писать конструкторы с таким большим количеством аргументов.
    
    Если аргументы разных типов, тогда их можно вводить в разном порядке. spring поймет какой аргумент, куда должен попасть. Но допустим мы для Integer указали значение 1 и для параметра String вы также указали значение 1. В таком случае вы можете указать тип аргумента:
    
    <bean id="client" class="Client">
    <constructor-arg type="java.lang.Integer"  value = "1"/>
    <constructor-arg type="java.lang.String"  value = "John Smith"/>
    </bean>
Это позволяет не привязываться к индексам.

Также можно записать в таком виде, но это будет работать только при включенных debug symbols. А как их включить хз.
    <bean id="client" class="Client">
    <constructor-arg name="arg1"  value = "1"/>
    <constructor-arg name="arg2"  value = "John Smith"/>
    </bean>
Итак, мы вынесли статическую информацию во внешний конфигурационный файл (context.xml). Это конечно не property файл, но его можно закоммитить и изменениям он будет производиться намного легче.



Как же проинжектить сами бины друг в друга!!!

Для того чтобы сделать бины в app есть ref:
    <bean id="app" class="App">
        <constructor-arg ref="client"/>
        <constructor-arg ref="eventLogger"/>
    </bean>
В конструктор не обязательно по порядку выставлять значения получаемых бинов, так как spring сам поймет по какому классу, какой бин куда вставлять.

Причем, стоит заметить, если spring не сумеет найти конструктор, принимающий нужное количество аргументов, то мы получим ошибку.
Если мы не указываем значения конструктора в xml, то он вызывает конструктор по умолчанию, который без параметров. 

Также нужно знать, что модификатор доступа в коструторе может быть любой (privat, public и т.д.) Spring вызовет коструктор и создаст объект в любом случае.



Итак на данный момент мы полностью создали описание контейнера spring в xml, определили в нем 3 бина. Теперь, представим spring создаст нам эти 3 объекта. Установит у клиента имя и id. А также передаст client и logger классу app. Нам остается только создать контейнер нашего приложения, ну и запустить его:

В Spring Framework - есть два типа контейнера:
- BeanFactory - это простейший контейнер. Он по большому счету делает только одно - это Dependency Injection. то есть он поднимается, создает бины и инжектит их куда надо. Больше он ничего не умеет делать.
- ApplicationContext - он делает все тоже самое, что и BeanFactory + предоставляет сервисы framework по управлению этими бинами.

Как же создать context в программе? 

Мы определяем переменную         
ApplicationContext ctx = new ClassPathXmlApplicationContext("spring.xml");
в скобочках написано где искать наш spring.xml файл.

Дальше мы вызываем метод getBean(), где мы передаем имя бина. В нашем примере - это app.
App app = (App) ctx.getBean("app");

Вообщето ApplicationContext имеет разные способы по получению бина: по имени, по классу,даже можно запросить бины, у которых есть определенная аннотация. Если мы запрашиваем бин по имени, то придется самому делать каст возвращаемого объекта. А если мы делаем по классу, либо по имени и классу, тогда катить не придется, благодаря jenerics.

При использовании ApplicationContext, мы можем передать несколько xml файлов, в которых могут быть описаны разные Beans. Они даже могут inject друг друга. В таком случае spring объединит описание и создаст один context со всеми бинами вместе.

Теперь, мы закончили создание простейшего приложения с использованием spring framework. Ну практически Hello world.
